#!/usr/bin/env python3
#   Copyright 2014, 2017, 2018 David Malcolm <dmalcolm@redhat.com>
#   Copyright 2014, 2017, 2018 Red Hat, Inc.
#
#   This is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see
#   <http://www.gnu.org/licenses/>.

# Tool for working with DejaGnu output

from collections import namedtuple
import difflib
import io
import os
import re
import sys
import unittest
import unittest.mock

import cmdln  # in Fedora as "python3-cmdln"

OUTCOMES = 'FAIL PASS XFAIL KFAIL XPASS KPASS UNTESTED UNRESOLVED UNSUPPORTED'.split()


def locate_exp_files(source_path):
    """
    Locate all .exp files below source_path
    """
    result = []
    for root, dirs, files in os.walk(source_path):
        for name in files:
            if name.endswith('.exp'):
                result.append(os.path.join(root, name))
    return result

############################################################################
# .sum and .log files
############################################################################


class TestId(namedtuple('TestId', ['testname', 'index'])):
    """
    A (name, index) pair, identifying e.g. one instance of
      'c-c++-common/pr83059.c  -std=c++11  (test for warnings, line 7)'
    (for which there are several in the test .sum files)
    """
    def get_line_num_info(self):
        """
        Get a (filename, details, start_line, end_line) 4-tuple for use
        when discarding test results that merely changed line.

        Return None if the testname doesn't contain any line numbers.

        For example, given this testname:
          "g++.dg/diagnostic/param-type-mismatch.C  -std=gnu++11  (test for errors, line 106)"
        return:
          ('g++.dg/diagnostic/param-type-mismatch.C',
           '  -std=gnu++11  (test for errors',
           106,
           106)
        and given this testname:
          ('g++.dg/diagnostic/param-type-mismatch.C  -std=gnu++11  expected multiline pattern lines 108-109 was found: "   '
           'return ptr->member_1 \(first, second, third\);.*\n                                             \^\n')
        return:
          ('g++.dg/diagnostic/param-type-mismatch.C',
           '  -std=gnu++11  expected multiline pattern lines    return ptr->member_1 \\(first, second, third\\);.*\\n      '
           '                                       \\^\\n',
           108,
           109)
        and given this testname w/o any line numbers:
          'g++.dg/diagnostic/nested-name-1.C  -std=gnu++98 (test for excess errors)'
        return None
        """
        m = re.match('(\S+)(.*\(test for .+), line ([0-9]+)\)', self.testname)
        if m:
            filename, details, linenum = m.groups()
            linenum = int(linenum)
            return filename, details, linenum, linenum
        m = re.match('(\S+)(.*expected multiline pattern lines )([0-9]+)-([0-9]+) was found: "(.*)"',
                     self.testname)
        if m:
            filename, details_a, linenum_a, linenum_b, details_b = m.groups()
            return (filename, details_a + details_b,
                    int(linenum_a), int(linenum_b))


class DejaFile:
    """
    Output from dejagnu, either a .log or a .sum file
    """
    def __init__(self, path):
        self.path = path
        # print('DejaFile(%r)' % self.path)

        # Lazily-populated list of .exp files
        self.exp_files = None

        # Mapping from TestId to outcome:
        # e.g. from the zeroth occurrence of:
        #   'libffi.call/closure_fn0.c -O0 -W -Wall (test for excess errors)'
        # to 'PASS'
        self.testid_to_outcome = {}

        # Mapping from outcome to set of TestId instances
        self.outcome_to_testids = {}
        for outcome in OUTCOMES:
            self.outcome_to_testids[outcome] = set()

        # Mapping from TestId to line index
        self.testid_to_lineidx = {}

        # Mapping from test name to last numeric index
        self.testname_to_last_index = {}

        # Parse the file and build the above dicts:
        with open(self.path) as f:
            self.parse_file(f)

    def parse_file(self, f):
        # gcc/testsuite/ada/acats/acats.sum uses a tab rather than a space
        # e.g. 'PASS:\ta22006b\n'
        PATTERN_PAIRS = [(outcome, re.compile('^%s:\s+(\S.*)$' % outcome))
                         for outcome in OUTCOMES]

        for idx, line in enumerate(f):
            for outcome, PATTERN in PATTERN_PAIRS:
                m = re.match(PATTERN, line)
                if m:
                    testname = m.group(1).rstrip()
                    if testname in self.testname_to_last_index:
                        next_index = self.testname_to_last_index[testname] + 1
                    else:
                        next_index = 0
                    testid = TestId(testname, next_index)
                    self.testname_to_last_index[testname] = next_index

                    self.testid_to_outcome[testid] = outcome
                    self.testid_to_lineidx[testid] = idx
                    self.outcome_to_testids[outcome].add(testid)
                    break  # OUTCOMES loop

    def find(self, search_testname):
        result = 0
        for cand_testid in sorted(self.testid_to_outcome):
            # substring matches
            if search_testname in cand_testid.testname:
                print('%s:%i: %s: %s'
                      % (self.path,
                         self.testid_to_lineidx[cand_testid] + 1,
                         self.testid_to_outcome[cand_testid],
                         cand_testid.testname))
                result += 1
        return result

    def get_count_by_outcome(self, outcome):
        return len(self.outcome_to_testids[outcome])

    def count_outcomes(self, testids):
        """
        Return a TotalByOutcome for the given sequence of TestId instances,
        all of which must be present.
        """
        total_by_outcome = TotalByOutcome()
        for testid in testids:
            outcome = self.testid_to_outcome[testid]
            total_by_outcome[outcome] += 1
        return total_by_outcome

    def locate_source_file(self, filename):
        """
        Given a filename within a testname
        (e.g. g++.dg/diagnostic/param-type-mismatch.C'"),
        attempt to locate the corresponding source file.
        """
        # If no source path was provided, we can't locate source files
        if self.source_path is None:
            return

        # Look relative to the .exp files found in the source tree
        if self.exp_files is None:
            self.exp_files = locate_exp_files(self.source_path)
            assert self.exp_files is not None

        for exp_file in self.exp_files:
            exp_dir = os.path.dirname(exp_file)
            # Look in the parent directory of the directory containing the
            # .exp file:
            maybe_src_dir = os.path.dirname(exp_dir)
            maybe_src_file = os.path.join(maybe_src_dir, filename)
            if os.path.exists(maybe_src_file):
                return maybe_src_file

    def get_filename_dict(self, testids):
        """
        Given a sequence of TestId instances, generate a dict mapping
        filenames mentioned in the testids to source file paths.
        """
        result = {}
        for testid in testids:
            line_num_info = testid.get_line_num_info()
            if not line_num_info:
                continue
            filename, details, linenum_a, linenum_b = line_num_info
            if filename in result:
                continue
            src = self.locate_source_file(filename)
            if not src:
                continue
            result[filename] = src
        return result


class LogFile(DejaFile):
    """
    A .log file from dejagnu
    """
    def __init__(self, path):
        DejaFile.__init__(self, path)

    def __repr__(self):
        return 'LogFile(%r)' % self.path


class SumFile(DejaFile):
    """
    A .sum file from dejagnu
    """
    def __init__(self, path, source_path, parse_log_file=False):
        DejaFile.__init__(self, path)
        self.source_path = source_path

        # Locate the .log file that this is a summary of:
        root, ext = os.path.splitext(path)
        self.logpath = root + '.log'

        # ...but don't parse it yet, as that's expensive:
        self.logfile = None

    def load_log_file(self):
        if not self.logfile:
            try:
                self.logfile = LogFile(self.logpath)
            except FileNotFoundError:
                pass

    def __repr__(self):
        return 'SumFile(%r)' % self.path

    def __lt__(self, other):
        return self.path < other.path

    def relative_path(self, basedir):
        return os.path.relpath(self.path, basedir)

    def find(self, testname):
        count = DejaFile.find(self, testname)
        if count:
            # Also find within .log file:
            self.load_log_file()
            if self.logfile:
                count += self.logfile.find(testname)

        return count

    def summarize(self, tr):
        tr.begin_section(self.path)
        for outcome in OUTCOMES:
            if self.outcome_to_testids[outcome]:
                tr.writeln('%s: %i tests'
                           % (outcome, self.get_count_by_outcome(outcome)))
        tr.end_section()


class TestRun:
    """
    A collection of .sum files (and their .log files); either
    one or more individual ones, or a directory.
    """
    def __init__(self, path, source_path):
        self.path = path
        self.source_path = source_path
        self.sumfiles = []
        if os.path.isdir(path):
            # Locate within the directory structure:
            for dirname, _, names in os.walk(path):
                for name in sorted(names):
                    if name.endswith('.sum'):
                        sf = SumFile(os.path.join(dirname, name),
                                     source_path)
                        # print(sf.logfile.testname_to_outcome)
                        # print(sf.logfile.testname_to_lineidx)
                        # print(sf.logfile.outcome_to_testnames)
                        self.sumfiles.append(sf)
        elif path.endswith('.sum'):
            # Locate individual file:
            sf = SumFile(path, source_path)
            self.sumfiles.append(sf)
        else:
            raise ValueError('expected a directory or a .sum file')

    def make_dict_by_rel_path(self):
        result = {}
        for sumfile in self.sumfiles:
            rel_path = sumfile.relative_path(self.path)
            # Special-case for a run specifiying an individual .sum file:
            # use just the filename, rather than ".":
            if rel_path == '.':
                rel_path = os.path.basename(sumfile.path)
            result[rel_path] = sumfile
        return result

    def compare(self, other):
        pass

    def dump(self, tr):
        for sumfile in sorted(self.sumfiles):
            tr.begin_section(sumfile.path)
            for outcome in OUTCOMES:
                tr.begin_section('%s: %i tests'
                                 % (outcome, sumfile.get_count_by_outcome(outcome)))
                for testid in sorted(sumfile.outcome_to_testids[outcome]):
                    tr.writeln(testid.testname)
                tr.end_section()
            tr.end_section()

    def find(self, testname):
        count = 0
        for sumfile in sorted(self.sumfiles):
            count += sumfile.find(testname)
        return count

    def summarize(self, tr):
        for sumfile in sorted(self.sumfiles):
            sumfile.summarize(tr)

############################################################################
# Various kinds of output
############################################################################


class TextReporter:
    def __init__(self):
        self.indent = 0

    def begin_section(self, title):
        self.writeln(title)
        self.writeln('-' * len(title))
        self.writeln('')
        self.indent += 1

    def end_section(self):
        self.writeln('')
        self.indent -= 1

    def writeln(self, text):
        if text == '':
            print('')
        else:
            print('%s%s' % (' ' * self.indent, text))

############################################################################
# Implementation details of "do_compare"
############################################################################


class TotalByOutcome(dict):
    def __init__(self):
        for outcome in OUTCOMES:
            self[outcome] = 0

    def __str__(self):
        result = ''
        for outcome in OUTCOMES:
            if not self[outcome]:
                continue
            if result:
                result += ', '
            result += '%s: %i' % (outcome, self[outcome])
        return result


def make_count_text(desc, countA, countB, with_percent=False):
    if countA == countB:
        return (' %s: %i'
                % (desc, countA))
    else:
        diff = countB - countA
        result = (' %s: %i->%i (%s)'
                  % (desc, countA, countB,
                     ('+%i' % diff if diff > 0 else '%i' % diff)))
        if with_percent:
            percent = countB * 100. / countA
            result += ' %2.2f%%' % percent
        return result


def read_lines(path):
    with open(path) as f:
        return f.readlines()


class LineMatcher:
    """
    A class for mapping lines in filenameA to those that are unchanged
    in filenameB, based on difflib.SequenceMatcher.
    """
    def __init__(self, filenameA, filenameB):
        linesA = read_lines(filenameA)
        linesB = read_lines(filenameB)
        sm = difflib.SequenceMatcher(None, linesA, linesB)
        self.matching_blocks = list(sm.get_matching_blocks())

    def get(self, linenumA):
        """
        Given a line number in filenameA, attempt to locate the
        corresponding line number in filename B, or return None.
        Both line numbers should be 1-based.
        """
        zero_based_linenumA = linenumA - 1
        for m in self.matching_blocks:
            if zero_based_linenumA >= m.a \
               and zero_based_linenumA < m.a + m.size:
                offset = zero_based_linenumA - m.a
                zero_based_linenumB = m.b + offset
                linenumB = zero_based_linenumB + 1
                return linenumB


def remap_for_changing_line_numbers(sumfileA, testidsA,
                                    sumfileB, testidsB):
    """
    Given a pair of SumFiles and a pair of sets of TestIds,
    return the pair of sets of TestIds, but with some TestIds
    removed, corresponding to unrelated line number changes.

    Specifically, any TestIds that are identical with a peer TestId
    in the other set, *apart* from line number can be removed,
    provided that the line number difference corresponds to a
    renumbering due to the changes in the pertinent source file.
    """
    # Look at "missing" test ids; did they really just change line number?
    missing = testidsA - testidsB
    new = testidsB - testidsA

    missing_files = sumfileA.get_filename_dict(missing)
    new_files = sumfileB.get_filename_dict(new)

    line_matchers_by_filename = {}

    for testidA in sorted(missing):
        line_num_infoA = testidA.get_line_num_info()
        if not line_num_infoA:
            continue
        filenameA, detailsA, startlineA, endlineA = line_num_infoA
        if filenameA not in missing_files:
            continue
        if filenameA not in new_files:
            continue
        if filenameA not in line_matchers_by_filename:
            line_matchers_by_filename[filenameA] \
                = LineMatcher(missing_files[filenameA],
                              new_files[filenameA])
        lm = line_matchers_by_filename[filenameA]
        expected_startlineB = lm.get(startlineA)
        if expected_startlineB is None:
            continue
        expected_endlineB = lm.get(endlineA)
        if expected_endlineB is None:
            continue
        # TODO: avoid O(N^2) here?
        for testidB in new:
            line_num_infoB = testidB.get_line_num_info()
            if not line_num_infoB:
                continue
            filenameB, detailsB, startlineB, endlineB = line_num_infoB
            if (filenameA, detailsA, expected_startlineB, expected_endlineB) \
               != (filenameB, detailsB, startlineB, endlineB):
                continue

            assert testidA in sumfileA.testid_to_outcome
            assert testidB in sumfileB.testid_to_outcome
            if sumfileA.testid_to_outcome[testidA] \
               != sumfileB.testid_to_outcome[testidB]:
                # The outcome changed; don't remove it, as we want to
                # report PASS -> FAIL changes etc
                continue

            # This test changed line, but the outcome is unchanged;
            # drop it from the set of changes.
            if 0:
                print('test changed line: A: %r B: %r'
                      % (line_num_infoA, line_num_infoB))
            testidsA.remove(testidA)
            testidsB.remove(testidB)
            break

    return testidsA, testidsB


class Comparison:
    def __init__(self,
                 before_path, old_source_path,
                 after_path, new_source_path):
        self.runA = TestRun(before_path, old_source_path)
        self.runB = TestRun(after_path, new_source_path)

        self.dict_by_rel_pathA = self.runA.make_dict_by_rel_path()
        self.dict_by_rel_pathB = self.runB.make_dict_by_rel_path()

        self.relpathsA = set(self.dict_by_rel_pathA.keys())
        self.relpathsB = set(self.dict_by_rel_pathB.keys())

        self.total_by_outcomeA = TotalByOutcome()
        self.total_by_outcomeB = TotalByOutcome()

        self.issue_count = 0

    def print_missing_sum_files(self, tr):
        missing_relpaths = self.relpathsA - self.relpathsB
        if missing_relpaths:
            tr.begin_section('sum files that went away: %i'
                             % len(missing_relpaths))
            for relpath in sorted(missing_relpaths):
                sumfileA = self.dict_by_rel_pathA[relpath]
                sumfileA.summarize(tr)
                for outcome in OUTCOMES:
                    self.total_by_outcomeA[outcome] \
                        += sumfileA.get_count_by_outcome(outcome)
                self.issue_count += 1
            tr.end_section()

    def print_new_sum_files(self, tr):
        new_relpaths = self.relpathsB - self.relpathsA
        if new_relpaths:
            tr.begin_section('sum files that appeared: %i'
                             % len(new_relpaths))
            for relpath in sorted(new_relpaths):
                sumfileB = self.dict_by_rel_pathB[relpath]
                sumfileB.summarize(tr)
                for outcome in OUTCOMES:
                    self.total_by_outcomeB[outcome] \
                        += sumfileB.get_count_by_outcome(outcome)
                self.issue_count += 1
            tr.end_section()

    def compare_sum_files(self, tr):
        """Compare .sum files for which there are matching peers"""
        tr.begin_section('Comparing %i common .sum files'
                         % len(self.relpathsA & self.relpathsB))
        self.initial_summary(tr)
        tr.end_section()
        self.detailed_comparison(tr)

    def initial_summary(self, tr):
        for relpath in sorted(self.relpathsA & self.relpathsB):
            sumfileA = self.dict_by_rel_pathA[relpath]
            sumfileB = self.dict_by_rel_pathB[relpath]
            outcome_text = make_count_text('total',
                                           len(sumfileA.testid_to_outcome),
                                           len(sumfileB.testid_to_outcome))
            for outcome in OUTCOMES:
                countA = sumfileA.get_count_by_outcome(outcome)
                countB = sumfileB.get_count_by_outcome(outcome)
                if countA or countB:
                    outcome_text += make_count_text(outcome, countA, countB)
                self.total_by_outcomeA[outcome] += countA
                self.total_by_outcomeB[outcome] += countB
            tr.writeln('%s :%s' % (relpath, outcome_text))

    def libgccjit_workaround(self, tr, sumfileA, sumfileB):
        """
        Subroutine of detailed_comparison.
        Workaround for bug with jit.sum:
          https://gcc.gnu.org/bugzilla/show_bug.cgi?id=69435
        which leads to unpredictable splitting/truncation of
        test names.
        Workaround it by not attempting to compare test names
        within jit.sum; just compare the count for each outcome,
        and complain if any are different.
        """
        section = False
        for outcome in OUTCOMES:
            countA = sumfileA.get_count_by_outcome(outcome)
            countB = sumfileB.get_count_by_outcome(outcome)
            if countA != countB:
                if not section:
                    section = True
                    tr.begin_section('Changes to jit.sum')
                tr.writeln(make_count_text(outcome, countA, countB))
                self.issue_count += 1
        if section:
            tr.end_section()

    def detailed_comparison(self, tr):
        for relpath in sorted(self.relpathsA & self.relpathsB):
            sumfileA = self.dict_by_rel_pathA[relpath]
            sumfileB = self.dict_by_rel_pathB[relpath]

            if os.path.basename(sumfileA.path) == 'jit.sum':
                self.libgccjit_workaround(tr, sumfileA, sumfileB)
                continue

            # Compare the individual tests
            testidsA = set(sumfileA.testid_to_outcome.keys())
            testidsB = set(sumfileB.testid_to_outcome.keys())
            testidsA, testidsB \
                = remap_for_changing_line_numbers(sumfileA, testidsA,
                                                  sumfileB, testidsB)
            missing_testids = testidsA - testidsB
            if missing_testids:
                tr.begin_section('Tests that went away in %s: %s'
                                 % (relpath, sumfileA.count_outcomes(missing_testids)))
                for testid in sorted(missing_testids):
                    tr.writeln('%s: %s'
                               % (sumfileA.testid_to_outcome[testid],
                                  testid.testname))
                    self.issue_count += 1
                tr.end_section()

            new_testids = testidsB - testidsA
            if new_testids:
                tr.begin_section('Tests appeared in %s: %s'
                                 % (relpath, sumfileB.count_outcomes(new_testids)))
                for testid in sorted(new_testids):
                    tr.writeln('%s: %s'
                               % (sumfileB.testid_to_outcome[testid],
                                  testid.testname))
                    self.issue_count += 1
                tr.end_section()

            # dict mapping from testid to (before, after) outcome pairs
            changing = {}
            for testid in sorted(testidsA & testidsB):
                outcomeA = sumfileA.testid_to_outcome[testid]
                outcomeB = sumfileB.testid_to_outcome[testid]
                if outcomeA != outcomeB:
                    changing[testid] = (outcomeA, outcomeB)
            if changing:
                tr.begin_section('Tests changing outcome in %s: %i'
                                 % (relpath, len(changing)))
                for testid in sorted(changing.keys()):
                    outcomeA, outcomeB = changing[testid]
                    tr.writeln('%s -> %s : %s'
                               % (outcomeA, outcomeB, testid.testname))
                    self.issue_count += 1
                tr.end_section()

    def conclusion(self, tr):
        if self.relpathsA & self.relpathsB and self.issue_count == 0:
            tr.writeln('No differences found in %i common .sum files'
                       % len(self.relpathsA & self.relpathsB))
        else:
            tr.begin_section('Summary')
            tr.writeln(make_count_text('# of .sum files',
                                       len(self.relpathsA),
                                       len(self.relpathsB)))
            for outcome in OUTCOMES:
                countA = self.total_by_outcomeA[outcome]
                countB = self.total_by_outcomeB[outcome]
                if countA or countB:
                    tr.writeln(make_count_text(outcome, countA, countB,
                                               outcome == 'PASS'))
            tr.end_section()


class SourcelessComparison(Comparison):
    def __init__(self, before_path, after_path):
        Comparison.__init__(self, before_path, None, after_path, None)

############################################################################
# Command-line interface
############################################################################


class JV(cmdln.Cmdln):
    name = 'jv'

    @cmdln.option("--new-source-path", metavar='DIR',
                  help='path to source files for "after" run')
    @cmdln.option("--old-source-path", metavar='DIR',
                  help='path to source files for "before" run')
    def do_compare(self, subcmd, opts, before_path, after_path):
        """
        Compare a "before" run to an "after" run.
        Accepts a pair of directories, or a pair of .sum files.

        If a pair of directories, assume that they have the same
        underlying structure when peer-matching (all descendent
        .sum files will be scanned).

        Returns the number of issues found (missing .sum files,
        new failures, etc).

        ${cmd_usage}
        ${cmd_option_list}
        """
        c = Comparison(before_path, opts.old_source_path,
                       after_path, opts.new_source_path)

        tr = TextReporter()

        c.print_missing_sum_files(tr)
        c.print_new_sum_files(tr)
        c.compare_sum_files(tr)
        c.conclusion(tr)

        return c.issue_count

    def do_dump(self, subcmd, opts, *paths):
        """
        Print a dump of one or more .sum files, or directories, categorized
        by outcome.
        """
        for path in paths:
            run = TestRun(path, None)
            tr = TextReporter()
            run.dump(tr)

    def do_find(self, subcmd, opts, testname, *paths):
        """
        Locate a test, by name, in the given .sum files or directories.

        If a test is located in a .sum file, jv will also look for the
        test in the corresponding .log file.

        Example:
          ./jv find \
            "c-c++-common/Wcast-qual-1.c -std=gnu++11  (test for warnings, line 100)" \
            testdata/control

        Return the number of matches found
        """
        count = 0
        for path in paths:
            run = TestRun(path, None)
            count += run.find(testname)
        return count

    def do_summarize(self, subcmd, opts, *paths):
        """
        Print a short summary of one or more .sum files or directories.
        """
        for path in paths:
            run = TestRun(path, None)
            tr = TextReporter()
            run.summarize(tr)

    def do_test(self, subcmd, opts, *paths):
        """
        Run jv's own selftests.
        """
        unittest.main(argv=[sys.argv[0], '-v'])


def mock_stdout():
    return unittest.mock.patch('sys.stdout', new=io.StringIO())


def get_first_lines(data, count):
    lines = data.splitlines()
    lines = lines[:count]
    return ''.join(line + '\n' for line in lines)


class TestSupportFunctions(unittest.TestCase):
    def test_locate_exp_files(self):
        self.assertEqual(locate_exp_files('testdata/changing-linenums/old/src'),
                         ['testdata/changing-linenums/old/src/gcc/testsuite/g++.dg/dg.exp'])
        self.assertEqual(locate_exp_files('testdata/changing-linenums/new/src'),
                         ['testdata/changing-linenums/new/src/gcc/testsuite/g++.dg/dg.exp'])

    def test_get_first_lines(self):
        self.assertMultiLineEqual(get_first_lines('', 0), '')
        self.assertMultiLineEqual(get_first_lines('', 5), '')
        THREE_LINES = ('foo\n'
                       'bar\n'
                       'baz\n')
        self.assertMultiLineEqual(get_first_lines(THREE_LINES, 0), '')
        self.assertMultiLineEqual(get_first_lines(THREE_LINES, 2),
                                  'foo\n'
                                  'bar\n')
        self.assertMultiLineEqual(get_first_lines(THREE_LINES, 4),
                                  THREE_LINES)


class TestTestRun(unittest.TestCase):
    def test_finding_sum_files_recursively(self):
        runA = TestRun('testdata/control', None)
        dict_by_rel_pathA = runA.make_dict_by_rel_path()
        sumfileA = dict_by_rel_pathA['g++.sum']
        self.assertEqual(sumfileA.path, 'testdata/control/g++.sum')

    def test_individual_sum_file(self):
        runA = TestRun('testdata/control/g++.sum', None)
        dict_by_rel_pathA = runA.make_dict_by_rel_path()
        sumfileA = dict_by_rel_pathA['g++.sum']
        self.assertEqual(sumfileA.path, 'testdata/control/g++.sum')

    def test_bogus_path(self):
        with self.assertRaisesRegex(ValueError,
                                    'expected a directory or a .sum file'):
            runA = TestRun('Makefile', None)


class TestSumFile(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.sumfile = SumFile('testdata/control/g++.sum', None)

    def test_summarize(self):
        tr = TextReporter()
        with mock_stdout() as fake_stdout:
            self.sumfile.summarize(tr)
        self.assertEqual(fake_stdout.getvalue(),
                         'testdata/control/g++.sum\n'
                         '------------------------\n'
                         '\n'
                         ' FAIL: 8 tests\n'
                         ' PASS: 119872 tests\n'
                         ' XFAIL: 434 tests\n'
                         ' UNSUPPORTED: 4697 tests\n'
                         '\n')

    def test_get_count_by_outcome(self):
        self.assertEqual(self.sumfile.get_count_by_outcome('FAIL'), 8)
        self.assertEqual(self.sumfile.get_count_by_outcome('PASS'), 119872)
        self.assertEqual(self.sumfile.get_count_by_outcome('XFAIL'), 434)
        self.assertEqual(self.sumfile.get_count_by_outcome('UNSUPPORTED'), 4697)
        self.assertEqual(self.sumfile.get_count_by_outcome('UNRESOLVED'), 0)

    def test_one_test_unique(self):
        TESTNAME \
            = 'c-c++-common/asan/alloca_big_alignment.c   -O0  execution test'
        testid = TestId(TESTNAME, 0)
        self.assertEqual(self.sumfile.testid_to_outcome[testid], 'PASS')
        self.assertIn(testid, self.sumfile.outcome_to_testids['PASS'])
        self.assertEqual(self.sumfile.testid_to_lineidx[testid], 21)

    def test_one_test_repeated(self):
        TESTNAME \
            = 'c-c++-common/pr83059.c  -std=c++11  (test for warnings, line 7)'
        # There are 3 instances of this testname, each with PASS
        for i in range(3):
            testid = TestId(TESTNAME, i)
            self.assertEqual(self.sumfile.testid_to_outcome[testid], 'PASS')
            self.assertIn(testid, self.sumfile.outcome_to_testids['PASS'])
            self.assertEqual(self.sumfile.testid_to_lineidx[testid], 18456 + i)


class TestComparison(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.c = SourcelessComparison('testdata/control', 'testdata/experiment')

    def test_print_missing_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_missing_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_print_new_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_new_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_compare_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.compare_sum_files(tr)
        self.assertIn(' g++.sum : total: 125011->125021 (+10)'
                      ' FAIL: 8->11 (+3) PASS: 119872->119879 (+7)'
                      ' XFAIL: 434 UNSUPPORTED: 4697\n', fake_stdout.getvalue())
        self.assertIn('Tests that went away in g++.sum: PASS: 323\n',
                      fake_stdout.getvalue())
        self.assertIn('Tests appeared in g++.sum: PASS: 333\n',
                      fake_stdout.getvalue())

    def test_conclusion(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.conclusion(tr)
        self.assertMultiLineEqual(fake_stdout.getvalue(),
                                  'Summary\n'
                                  '-------\n'
                                  '\n'
                                  '  # of .sum files: 1\n'
                                  '  FAIL: 8->11 (+3)\n'
                                  '  PASS: 119872->119879 (+7) 100.01%\n'
                                  '  XFAIL: 434\n'
                                  '  UNSUPPORTED: 4697\n'
                                  '\n')


class TestComparisonSumFileAppears(unittest.TestCase):
    """
    Test what happens when a new .sum file appears (by comparing against
    an empty directory).
    """
    @classmethod
    def setUpClass(cls):
        cls.c = SourcelessComparison('testdata/empty', 'testdata/experiment')

    def test_print_missing_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_missing_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_print_new_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_new_sum_files(tr)
        EXPECTED = (
            'sum files that appeared: 1\n'
            '--------------------------\n'
            '\n'
            ' testdata/experiment/g++.sum\n'
            ' ---------------------------\n'
            '\n'
            '  FAIL: 11 tests\n'
            '  PASS: 119879 tests\n'
            '  XFAIL: 434 tests\n'
            '  UNSUPPORTED: 4697 tests\n'
            '\n'
            '\n')
        self.assertEqual(fake_stdout.getvalue(), EXPECTED)

    def test_compare_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.compare_sum_files(tr)
        EXPECTED = (
            'Comparing 0 common .sum files\n'
            '-----------------------------\n'
            '\n'
            '\n')
        self.assertMultiLineEqual(fake_stdout.getvalue(), EXPECTED)

    def test_conclusion(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.conclusion(tr)
        EXPECTED = (
            'Summary\n'
            '-------\n'
            '\n'
            '  # of .sum files: 0->1 (+1)\n'
            '\n')
        self.assertMultiLineEqual(fake_stdout.getvalue(), EXPECTED)


class TestComparisonSumFileDisappears(unittest.TestCase):
    """
    Test what happens when a .sum file disappears (by comparing against
    an empty directory).
    """
    @classmethod
    def setUpClass(cls):
        cls.c = SourcelessComparison('testdata/experiment', 'testdata/empty')

    def test_print_missing_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_missing_sum_files(tr)
        EXPECTED = (
            'sum files that went away: 1\n'
            '---------------------------\n'
            '\n'
            ' testdata/experiment/g++.sum\n'
            ' ---------------------------\n'
            '\n'
            '  FAIL: 11 tests\n'
            '  PASS: 119879 tests\n'
            '  XFAIL: 434 tests\n'
            '  UNSUPPORTED: 4697 tests\n'
            '\n'
            '\n')
        self.assertEqual(fake_stdout.getvalue(), EXPECTED)

    def test_print_new_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_new_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_compare_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.compare_sum_files(tr)
        EXPECTED = (
            'Comparing 0 common .sum files\n'
            '-----------------------------\n'
            '\n'
            '\n')
        self.assertMultiLineEqual(fake_stdout.getvalue(), EXPECTED)

    def test_conclusion(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.conclusion(tr)
        EXPECTED = (
            'Summary\n'
            '-------\n'
            '\n'
            '  # of .sum files: 1->0 (-1)\n'
            '\n')
        self.assertMultiLineEqual(fake_stdout.getvalue(), EXPECTED)


class TestSelfComparison(unittest.TestCase):
    """
    Test what happens when nothing changes (by comparing a directory
    against itself).
    """
    @classmethod
    def setUpClass(cls):
        cls.c = SourcelessComparison('testdata/experiment', 'testdata/experiment')

    def test_print_missing_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_missing_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_print_new_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_new_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_compare_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.compare_sum_files(tr)
        EXPECTED = (
            'Comparing 1 common .sum files\n'
            '-----------------------------\n'
            '\n'
            ' g++.sum : total: 125021 FAIL: 11 PASS: 119879 XFAIL: 434 UNSUPPORTED: 4697\n'
            '\n')
        self.assertMultiLineEqual(fake_stdout.getvalue(), EXPECTED)

    def test_conclusion(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.conclusion(tr)
        EXPECTED = 'No differences found in 1 common .sum files\n'
        self.assertMultiLineEqual(fake_stdout.getvalue(), EXPECTED)


class TestEmptyComparison(unittest.TestCase):
    """
    Test what happens when comparing an empty directory against itself.
    """
    @classmethod
    def setUpClass(cls):
        cls.c = SourcelessComparison('testdata/empty', 'testdata/empty')

    def test_print_missing_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_missing_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_print_new_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_new_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')

    def test_compare_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.compare_sum_files(tr)
        EXPECTED = (
            'Comparing 0 common .sum files\n'
            '-----------------------------\n'
            '\n'
            '\n')
        self.assertEqual(fake_stdout.getvalue(), EXPECTED)

    def test_conclusion(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.conclusion(tr)
        EXPECTED = (
            'Summary\n'
            '-------\n'
            '\n'
            '  # of .sum files: 0\n'
            '\n')
        self.assertMultiLineEqual(fake_stdout.getvalue(), EXPECTED)


class TestRemappingLineNumbers(unittest.TestCase):
    """
    Verify the machinery for suppressing testcases that purely change
    their line number.
    """
    def test_locate_source_file(self):
        sumfileA = SumFile('testdata/changing-linenums/old/build/gcc/testsuite/g++/g++.sum',
                           source_path='testdata/changing-linenums/old/src')
        self.assertEqual(sumfileA.locate_source_file('does not exist'), None)
        self.assertEqual(sumfileA.locate_source_file('g++.dg/diagnostic/param-type-mismatch.C'),
                         'testdata/changing-linenums/old/src/gcc/testsuite/g++.dg/diagnostic/param-type-mismatch.C')
        self.assertEqual(sumfileA.locate_source_file('g++.dg/plugin/diagnostic-test-expressions-1.C'),
                         'testdata/changing-linenums/old/src/gcc/testsuite/g++.dg/plugin/diagnostic-test-expressions-1.C')

        sumfileB = SumFile('testdata/changing-linenums/new/build/gcc/testsuite/g++/g++.sum',
                           source_path='testdata/changing-linenums/new/src')
        self.assertEqual(sumfileB.locate_source_file('does not exist'), None)
        self.assertEqual(sumfileB.locate_source_file('g++.dg/diagnostic/param-type-mismatch.C'),
                         'testdata/changing-linenums/new/src/gcc/testsuite/g++.dg/diagnostic/param-type-mismatch.C')
        self.assertEqual(sumfileB.locate_source_file('g++.dg/plugin/diagnostic-test-expressions-1.C'),
                         'testdata/changing-linenums/new/src/gcc/testsuite/g++.dg/plugin/diagnostic-test-expressions-1.C')

    def get_test_testid(self):
        TESTNAME = 'g++.dg/diagnostic/param-type-mismatch.C  -std=gnu++11  (test for errors, line 106)'
        return TestId(TESTNAME, 0)

    def test_get_line_num_info(self):
        testid = self.get_test_testid()
        self.assertEqual(testid.get_line_num_info(),
                         ('g++.dg/diagnostic/param-type-mismatch.C',
                          '  -std=gnu++11  (test for errors',
                          106, 106))

        TESTNAME_2 = (r'g++.dg/diagnostic/param-type-mismatch.C  -std=gnu++11  expected multiline pattern lines 108-109'
                      r' was found: "   return ptr->member_1 \(first, second, third\);.*\n                              '
                      r'               \^\n"')
        testid_2 = TestId(TESTNAME_2, 0)
        self.assertEqual(testid_2.get_line_num_info(),
                         ('g++.dg/diagnostic/param-type-mismatch.C',
                          ('  -std=gnu++11  expected multiline pattern lines    return ptr->member_1 \\(first, second, '
                           'third\\);.*\\n                                             \\^\\n'),
                          108, 109))

        TESTNAME_3 = 'g++.dg/diagnostic/nested-name-1.C  -std=gnu++98 (test for excess errors)'
        testid_3 = TestId(TESTNAME_3, 0)
        self.assertEqual(testid_3.get_line_num_info(), None)

    def test_get_filename_dict(self):
        sumfile = SumFile('testdata/changing-linenums/old/build/gcc/testsuite/g++/g++.sum',
                          source_path='testdata/changing-linenums/old/src')
        testid = self.get_test_testid()
        d = sumfile.get_filename_dict(set([testid]))
        self.assertIn('g++.dg/diagnostic/param-type-mismatch.C', d)
        self.assertEqual(d['g++.dg/diagnostic/param-type-mismatch.C'],
                         'testdata/changing-linenums/old/src/gcc/testsuite/g++.dg/diagnostic/param-type-mismatch.C')

    def test_line_matcher(self):
        old = 'testdata/changing-linenums/old/src/gcc/testsuite/g++.dg/diagnostic/param-type-mismatch.C'
        new = old.replace('old', 'new')
        lm = LineMatcher(old, new)

        self.assertEqual(lm.get(106), 103)
        self.assertEqual(lm.get(124), 121)
        self.assertEqual(lm.get(14), 11)
        self.assertEqual(lm.get(1), 1)

    def test_remap_for_changing_line_numbers(self):
        """
        Verify that test thats merely change line number are eliminated by
        remap_for_changing_line_numbers.
        """

        # First for a single line number, moving from line 106 in old
        # source tree to line 103 in new source tree.

        sumfileA = SumFile('testdata/changing-linenums/old/build/gcc/testsuite/g++/g++.sum',
                           source_path='testdata/changing-linenums/old/src')
        sumfileB = SumFile('testdata/changing-linenums/new/build/gcc/testsuite/g++/g++.sum',
                           source_path='testdata/changing-linenums/new/src')

        TESTNAME_A = 'g++.dg/diagnostic/param-type-mismatch.C  -std=gnu++11  (test for errors, line 106)'
        TESTNAME_B = TESTNAME_A.replace('106', '103')

        testidsA = set([TestId(TESTNAME_A, 0)])
        testidsB = set([TestId(TESTNAME_B, 0)])

        testidsA, testidsB \
            = remap_for_changing_line_numbers(sumfileA, testidsA,
                                              sumfileB, testidsB)
        self.assertEqual(testidsA, set())
        self.assertEqual(testidsB, set())

        # Again, but for a multiline test, moving from lines 260-261 in
        # old source tree to lines 345-346.

        TESTNAME_A = (r'g++.dg/plugin/diagnostic-test-expressions-1.C -fplugin=./diagnostic_plugin_test_tree_expression'
                      r'_range.so  expected multiline pattern lines 260-261 was found: "   __emit_expression_range \(0, '
                      r'lhs / rhs \);.*\n                               ~~~~\^~~~~\n"')
        TESTNAME_B = TESTNAME_A.replace('260', '345')
        TESTNAME_B = TESTNAME_B.replace('261', '346')
        self.assertIn('345-346', TESTNAME_B)
        testidA = TestId(TESTNAME_A, 0)
        testidsA = set([testidA])
        testidB = TestId(TESTNAME_B, 0)
        testidsB = set([testidB])

        self.assertEqual(sumfileA.testid_to_outcome[testidA], 'PASS')
        self.assertEqual(sumfileB.testid_to_outcome[testidB], 'PASS')

        testidsA, testidsB \
            = remap_for_changing_line_numbers(sumfileA, testidsA,
                                              sumfileB, testidsB)
        self.assertEqual(testidsA, set())
        self.assertEqual(testidsB, set())

        # Verify that if the outcome changed, then the remapping
        # shouldn't occur:
        sumfileB.testid_to_outcome[testidB] = 'FAIL'
        testidsA = set([testidA])
        testidsB = set([testidB])
        testidsA, testidsB \
            = remap_for_changing_line_numbers(sumfileA, testidsA,
                                              sumfileB, testidsB)
        self.assertEqual(testidsA, set([testidA]))
        self.assertEqual(testidsB, set([testidB]))


class TestComparisonWithSource(unittest.TestCase):
    """
    Verify that the presence of source files allows us to suppress tests
    that merely changed line number (due to unrelated edits).
    """
    @classmethod
    def setUpClass(cls):
        cls.c = Comparison('testdata/changing-linenums/old/build', 'testdata/changing-linenums/old/src',
                           'testdata/changing-linenums/new/build', 'testdata/changing-linenums/new/src')

    def test_compare_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.compare_sum_files(tr)
        self.assertIn('g++.sum : total: 369->379 (+10) PASS: 369->379 (+10)\n',
                      fake_stdout.getvalue())
        self.assertIn('Tests that went away in gcc/testsuite/g++/g++.sum: PASS: 89',
                      fake_stdout.getvalue())  # would be 323 without suppression
        self.assertIn('Tests appeared in gcc/testsuite/g++/g++.sum: PASS: 99',
                      fake_stdout.getvalue())  # would be 333 without suppression

    def test_conclusion(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.conclusion(tr)
        self.assertMultiLineEqual(fake_stdout.getvalue(),
                                  'Summary\n'
                                  '-------\n'
                                  '\n'
                                  '  # of .sum files: 1\n'
                                  '  PASS: 369->379 (+10) 102.71%\n'
                                  '\n')


class CommandTest(unittest.TestCase):
    """
    Subclass for implementing integration tests for a command.
    """
    def cmd(self, args):
        """
        Run jv.main with the given args, returning the captured stdout.
        """
        jv = JV()
        with mock_stdout() as fake_stdout:
            jv.main(['jv'] + args)
        return fake_stdout.getvalue()


class TestComparisonCommand(CommandTest):
    """
    Integration testing for the "compare" command
    """
    def test_compare_files(self):
        out = self.cmd(['compare',
                        'testdata/with-log/old/boehm-gc.sum',
                        'testdata/with-log/new/boehm-gc.sum'])
        self.assertMultiLineEqual(out,
                                  'Comparing 1 common .sum files\n'
                                  '-----------------------------\n'
                                  '\n'
                                  ' boehm-gc.sum : total: 13 PASS: 12 UNSUPPORTED: 1\n'
                                  '\n'
                                  'No differences found in 1 common .sum files\n')

    def test_compare_directory(self):
        out = self.cmd(['compare',
                        'testdata/with-log/old',
                        'testdata/with-log/new'])
        self.assertMultiLineEqual(out,
                                  'Comparing 1 common .sum files\n'
                                  '-----------------------------\n'
                                  '\n'
                                  ' boehm-gc.sum : total: 13 PASS: 12 UNSUPPORTED: 1\n'
                                  '\n'
                                  'No differences found in 1 common .sum files\n')

    def test_jit_workaround_clean(self):
        out = self.cmd(['compare',
                        'testdata/jit-workaround/clean/old',
                        'testdata/jit-workaround/clean/new'])
        self.assertMultiLineEqual(out,
                                  'Comparing 1 common .sum files\n'
                                  '-----------------------------\n'
                                  '\n'
                                  ' jit.sum : total: 2 PASS: 2\n'
                                  '\n'
                                  'No differences found in 1 common .sum files\n')

    def test_jit_workaround_new_failure(self):
        out = self.cmd(['compare',
                        'testdata/jit-workaround/new-failure/old',
                        'testdata/jit-workaround/new-failure/new'])
        self.assertMultiLineEqual(out,
                                  'Comparing 1 common .sum files\n'
                                  '-----------------------------\n'
                                  '\n'
                                  ' jit.sum : total: 25->9 (-16) FAIL: 0->2 (+2) PASS: 25->7 (-18)\n'
                                  '\n'
                                  'Changes to jit.sum\n'
                                  '------------------\n'
                                  '\n'
                                  '  FAIL: 0->2 (+2)\n'
                                  '  PASS: 25->7 (-18)\n'
                                  '\n'
                                  'Summary\n'
                                  '-------\n'
                                  '\n'
                                  '  # of .sum files: 1\n'
                                  '  FAIL: 0->2 (+2)\n'
                                  '  PASS: 25->7 (-18) 28.00%\n'
                                  '\n')

    def test_new_failures(self):
        out = self.cmd(['compare',
                        'testdata/new-failures/old',
                        'testdata/new-failures/new'])
        self.assertIn('Tests appeared in gcc.sum: FAIL: 2, PASS: 12\n', out)


class TestDump(CommandTest):
    """
    Integration testing for the "dump" command
    """
    def verify_output(self, out):
        start = get_first_lines(out, 7)
        self.assertMultiLineEqual(start,
                                  'testdata/control/g++.sum\n'
                                  '------------------------\n'
                                  '\n'
                                  ' FAIL: 8 tests\n'
                                  ' -------------\n'
                                  '\n'
                                  '  g++.dg/ipa/devirt-22.C  -std=gnu++11  scan-ipa-dump-times cp "Discovered a virtual call to'
                                  ' a known target" 1 (found 2 times)\n')
        self.assertIn('PASS: 119872 tests', out)

    def test_dumping_one_file(self):
        out = self.cmd(['dump', 'testdata/control/g++.sum'])
        self.verify_output(out)

    def test_dumping_directory(self):
        out = self.cmd(['dump', 'testdata/control'])
        self.verify_output(out)


class TestFind(CommandTest):
    """
    Integration testing for the "find" command
    """
    TESTNAME = 'boehm-gc.c/leak_test.c -O2 execution test'

    def test_find_within_one_file(self):
        out = self.cmd(['find', self.TESTNAME,
                        'testdata/with-log/old/boehm-gc.sum'])
        self.assertMultiLineEqual(out,
                                  'testdata/with-log/old/boehm-gc.sum:14: PASS: boehm-gc.c/leak_test.c -O2 execution test\n'
                                  'testdata/with-log/old/boehm-gc.log:44: PASS: boehm-gc.c/leak_test.c -O2 execution test\n')

    def test_find_below_directory(self):
        out = self.cmd(['find', self.TESTNAME, 'testdata/with-log'])
        self.assertMultiLineEqual(out,
                                  'testdata/with-log/new/boehm-gc.sum:14: PASS: boehm-gc.c/leak_test.c -O2 execution test\n'
                                  'testdata/with-log/new/boehm-gc.log:44: PASS: boehm-gc.c/leak_test.c -O2 execution test\n'
                                  'testdata/with-log/old/boehm-gc.sum:14: PASS: boehm-gc.c/leak_test.c -O2 execution test\n'
                                  'testdata/with-log/old/boehm-gc.log:44: PASS: boehm-gc.c/leak_test.c -O2 execution test\n')

    def test_without_log_file(self):
        '''
        Verify 'find' on a .sum file that's missing its .log file.
        '''
        out = self.cmd(['find',
                        'g++.old-deja/g++.warn/cast-align1.C  -std=gnu++11',
                        'testdata/control'])
        EXP = 'testdata/control/g++.sum:124888: UNSUPPORTED: g++.old-deja/g++.warn/cast-align1.C  -std=gnu++11\n'
        self.assertMultiLineEqual(out, EXP)


class TestSummarize(CommandTest):
    """
    Integration testing for the "summarize" command
    """
    def test_summarize_one_file(self):
        out = self.cmd(['summarize', 'testdata/with-log/old/boehm-gc.sum'])
        self.assertMultiLineEqual(out,
                                  'testdata/with-log/old/boehm-gc.sum\n'
                                  '----------------------------------\n'
                                  '\n'
                                  ' PASS: 12 tests\n'
                                  ' UNSUPPORTED: 1 tests\n'
                                  '\n')

    def test_summarize_directory(self):
        out = self.cmd(['summarize', 'testdata/changing-linenums'])
        self.assertMultiLineEqual(out,
                                  'testdata/changing-linenums/new/build/gcc/testsuite/g++/g++.sum\n'
                                  '--------------------------------------------------------------\n'
                                  '\n'
                                  ' PASS: 379 tests\n'
                                  '\n'
                                  'testdata/changing-linenums/old/build/gcc/testsuite/g++/g++.sum\n'
                                  '--------------------------------------------------------------\n'
                                  '\n'
                                  ' PASS: 369 tests\n'
                                  '\n')


if __name__ == "__main__":
    jv = JV()
    sys.exit(jv.main())
